# 시작하기

## View

### 간단하게 컴포넌트 만들기

rune에서는 `View` 클래스를 상속하여 컴포넌트를 만듭니다.

```typescript
import { View, html } from 'rune-ts';

export type Color = {
  code: string;
};

export class ColorView extends View<Color> {
  template({ code }: Color) {
    return html`
      <div style="background-color: ${code}"></div>
    `;
  }
}

const colorView = new ColorView({ code: 'red' });
colorView.toHtml();
```

`colorView.toHtml()`은 아래와 같은 HTML 문자열을 리턴합니다.

```html
<div class="ColorView" style="background-color: red"></div>
```

### 데이터 변경하기

colorView의 데이터를 변경한 후 다시 html 문자열을 얻을 수 있습니다.

```typescript
colorView.data.code = 'blue';
colorView.toHtml();
```

```html
<div class="ColorView" style="background-color: blue"></div>
```

같은 코드를 메서드 체이닝으로 표현할 수 있습니다.

```typescript
colorView.setData({ code: 'blue' }).toHtml();
```

### HTMLElement 생성하기

`colorView.render();` 를 실행하면 HTMLElement 생성하여 리턴합니다. `render` 메서드는 브라우저단에서만 사용하는 것을 권장합니다.

```typescript
document.body.appendChild(
  new ColorView({ code: 'pink' }).render()
);
```
```html
<html>
...
<body>
...
<div class="ColorView" style="background-color: pink"></div>
</body>
</html>
```

### 중첩 컴포넌트 만들기

템플릿 리터럴을 이용하여 중첩 컴포넌트를 구현할 수 있습니다.

```typescript
export type Color = {
  code: string;
  checked?: boolean;
};

export class ColorCheckboxView extends View<Color> {
  template(color: Color) {
    return html`
      <li class="${color.checked ? 'checked' : ''}">
        ${new ColorView(color)}
      </li>
    `;
  }
}

new ColorCheckboxView(
  { code: 'yellow', checked: true }
).toHtml();
```

```html
<li class="ColorCheckboxView checked">
  <div class="ColorView" style="background-color: green"></div>
</li>
```
이와 같이 `ColorView`를 가지는 `ColorCheckboxView`를 만들 수 있습니다. 아래는 배열을 전달하여 여러개의 `ColorCheckboxView`를 가지는 `ColorCheckboxListView`를 만드는 예시입니다.

```typescript
export class ColorCheckboxListView extends View<Color[]> {
  template(colors: Color[]) {
    return html`
      <ul>
        ${colors.map(
          (color) => new ColorCheckboxView(color)
        )}
      </ul>
    `;
  }
}

document.body.appendChild(
    new ColorCheckboxListView([
      { code: 'red' },
      { code: 'green', checked: true },
      { code: 'blue' },
      { code: 'yellow' },
    ]).render(),
);
```



```html
<ul class="ColorCheckboxListView">
  <li class="ColorCheckboxView">
    <div class="ColorView" style="background-color: red"></div>
  </li>
  <li class="ColorCheckboxView checked">
    <div class="ColorView" style="background-color: green"></div>
  </li>
  ...
</ul>
```
### 이벤트 할당

`onMount()`는 `document.body` 내에 렌더링된 직후 실행되며 이벤트를 등록하기 적합한 시점입니다. `this.element()`는 `View`와 매핑된 `HTMLElement`를 리턴하며 Web API의 `addEventListener()`를 이용하여 이벤트를 등록할 수 있습니다.

```typescript

export class ColorCheckboxView extends View<Color> {
  template(color: Color) {
    return html`
      <li class="${color.checked ? 'checked' : ''}">
        ${new ColorView(color)}
      </li>
    `;
  }

  onMount() {
    this.element().addEventListener('click', () => this.toggle());
  }

  toggle() {
    this.data.checked = !this.data.checked;
    this.element().classList.toggle('checked');
  }
}
```

위 코드는 나쁘지 않지만 `ColorCheckboxView`가 매우 많아질 경우 등록된 이벤트 리스너도 함께 많아지게 됩니다. 이를 방지하기 위해 `View`는 `addEventListener`를 확장한 메서드를 제공합니다.

```typescript
export class ColorCheckboxView extends View<Color> {
  ...
  onMount() {
    this.addEventListener('click', this.toggle);
    // or this.addEventListener('click', 'toggle');
  }

  toggle() {
    this.data.checked = !this.data.checked;
    this.element().classList.toggle('checked');
  }
}
```

`view.addEventListener()`는 받은 함수를 등록해두었다가 이벤트가 실행되었을 때 `this`에 `view`를 바인딩하여 실행합니다. 위 코드에서 `ColorCheckboxView.prototype.toggle`은 하나의 함수이기 때문에 여러개의 ColorCheckboxView가 만들어지더라도 효율적입니다. 혹은 `'toggle'`과 같이 메서드명을 전달해도 됩니다.

### 이벤트 등록 데코레이터

`@on` 데코레이터를 사용하면 보다 간결하게 코드를 작성할 수 있습니다. `@on('click')`은 `onMount` 내 작성했던 코드를 대체합니다. 

```typescript
export class ColorCheckboxView extends View<Color> {
  @on('click')
  toggle() {
    this.data.checked = !this.data.checked;
    this.element().classList.toggle('checked');
  }
}
```


### 커스텀 이벤트 디스패치와 이벤트 델리게이트

```typescript
export class ColorCheckboxView extends View<Color> {
  ...
  @on('click')
  toggle() {
    this.data.checked = !this.data.checked;
    this.element().classList.toggle('checked');
    this.element().dispatchEvent(
      new CustomEvent('checkbox:change', { bubbles: true })
    );
  }
}
```

위와 같이`dispatchEvent()`를 사용하여 이벤트를 발생시킬 수 있습니다. `checkbox:`는 중복을 피하기위한 일종의 컨벤션이며 기능은 없습니다. 또한 아래처럼 `View`의 인스턴스 메서드 `delegate()`를 통해 이벤트를 들을 수 있습니다.

```typescript
export class ColorCheckboxListView extends View<Color[]> {
  ...
  onMount() {
    this.delegate('checkbox:change', '.ColorCheckboxView', (e) => {
      console.log(e.target);
      // <li class="ColorCheckboxView checked">...</li>
    });

    this.delegate('click', '.ColorCheckboxView', (e) => {
      console.log(e.currentTarget);
      // <li class="ColorCheckboxView checked">...</li>
      console.log(e.target);
      // <div class="ColorView" style="background-color: yellow">...</div>
    });
  }
}
```

`@on` 데코레이터에 인자를 하나만 전달하면 `addEventListener`를 사용하고, `@on`에 두 번째 인자로 CSS 셀렉터를 함께 전달하면 `delegate`를 사용합니다. `delegate`도 데코레이터로 아래처럼 간결하게 작성할 수 있습니다.

```typescript

class MyView extends View<number> {
  onMount() {
    this.delegate('click', '.target', () => this.remove());
  }
  
  remove() {
    this.element().remove();
  }
}

class MyView extends View<number> {
  @on('click', '.target')
  remove() {
    this.element().remove();
  }
}
```

### ColorCheckBoxListView 마무리

```typescript
export class ColorCheckboxListView extends View<Color[]> {
  template(colors: Color[]) {
    return html`
      <ul>
        ${colors.map((color) => new ColorCheckboxView(color))}
      </ul>
    `;
  }

  onMount() {
    this.delegate('checkbox:change', '.ColorCheckboxView', this.onChange);
  }

  onChange() {
    this.element().dispatchEvent(
      new CustomEvent('checkboxlist:change', { bubbles: true }),
    );
  }

  checkedColors(): Color[] {
    return this.data.filter(({ checked }) => checked);
  }
}

const colorCheckboxListView = new ColorCheckboxListView([
  { code: 'red' },
  { code: 'green', checked: true },
  { code: 'blue' },
  { code: 'yellow' },
]);

document.body.appendChild(colorCheckboxListView.render());

colorCheckboxListView.addEventListener('checkboxlist:change', function () {
  console.log(this.checkedColors().map(({ code }) => code));
  // ['green', 'blue']
});
```

## View 추상화하기

### 체크하는 기능을 분리하기

위의 `ColorCheckboxListView`와 `ColorCheckboxView`는 체크할 수 있다는 속성을 가지고 있습니다. 체크 기능을 추상화한 `View`를 준비하면 체크 기능이 적용된 더 많은 `View`를 보다 쉽게 만들 수 있습니다.

먼저 `ColorView`, `ColorCheckboxListView`, `ColorCheckboxView`의 코드를 다시보면 아래와 같습니다.

```typescript
export type Color = {
  code: string;
  checked?: boolean;
};

export class ColorView extends View<Color> {
  template({ code }: Color) {
    return html`
        <div style="background-color: ${code}"></div>
      `;
  }
}

export class ColorCheckboxView extends View<Color> {
  template(color: Color) {
    return html`
      <li class="${color.checked ? 'checked' : ''}">
        ${new ColorView(color)}
      </li>
    `;
  }

  @on('click')
  toggle() {
    this.data.checked = !this.data.checked;
    this.element().classList.toggle('checked');
    this.element().dispatchEvent(
      new CustomEvent('checkbox:change', { bubbles: true })
    );
  }
}

export class ColorCheckboxListView extends View<Color[]> {
  template(colors: Color[]) {
    return html`
      <ul>
        ${colors.map((color) => new ColorCheckboxView(color))}
      </ul>
    `;
  }

  onMount() {
    this.delegate('checkbox:change', '.ColorCheckboxView', this.onChange);
  }

  onChange() {
    this.element().dispatchEvent(
      new CustomEvent('checkboxlist:change', { bubbles: true })
    );
  }

  checkedColors(): Color[] {
    return this.data.filter(({ checked }) => checked);
  }
}

```

### 추상화된 클래스와 제네릭

`ColorCheckboxListView`, `ColorCheckboxView`를 아래와 같은 방법으로 추상화할 수 있습니다. 이전 코드와 비교하여 변한 부분을 확인해보세요.

```typescript
export type CheckboxData = {
  checked?: boolean;
};

export class CheckboxView<T extends CheckboxData> extends View<T> {
  tagName: string = 'li';
  SubView: { new (data: T): View<T> } | null = null;

  template({ checked }: T) {
    return html`
      <${this.tagName} class="${checked ? 'checked' : ''}">
        ${this.createSubView()}
      </${this.tagName}>
    `;
  }

  createSubView(): View<T> | string {
    return this.SubView ? new this.SubView(this.data) : '';
  }

  @on('click')
  toggle() {
    this.data.checked = !this.data.checked;
    this.element().classList.toggle('checked');
    this.element().dispatchEvent(
      new CustomEvent('checkbox:change', { bubbles: true })
    );
  }
}

export class CheckboxListView<T extends CheckboxData> extends View<T[]> {
  tagName: string = 'ul';
  CheckboxView: { new (data: T): CheckboxView<T> } = CheckboxView;

  template(checkBoxDatas: T[]) {
    return html`
      <${this.tagName}>
        ${checkBoxDatas.map(
          (checkBoxData) => this.createCheckboxView(checkBoxData)
        )}
      </${this.tagName}>
    `;
  }

  createCheckboxView(data: T): CheckboxView<T> {
    return new this.CheckboxView(data);
  }

  @on('checkbox:change', '> *')
  onChange() {
    this.element().dispatchEvent(
      new CustomEvent('checkboxlist:change', { bubbles: true })
    );
  }

  checkedData() {
    return this.data.filter(({ checked }) => checked);
  }
}
```

제네릭을 활용하여 `CheckboxListView`, `CheckboxView`를 확장할 코드들에서 `data`의
타입을 추론할 수 있도록 하였습니다. `CheckboxView<T extends CheckboxData>`는 `CheckboxView`을 확장할 새로운 `View`의 `data`의 타입을 제약합니다. 또한 `tagName`, `SubView`, `CheckboxView` 등을 확장할 수 있도록 프로퍼티를 추가했습니다.


### 상속으로 확장하기

`CheckboxView`와 `CheckboxListView`를 상속하여 `ColorCheckboxListView`, `ColorCheckboxView`를 다시 구현하면 아래와 같습니다.

```typescript
export class ColorCheckboxView extends CheckboxView<Color> {
  SubView = ColorView;
}

export class ColorCheckboxListView extends CheckboxListView<Color> {
  CheckboxView = ColorCheckboxView;
}
```

동일하게 사용할 수 있습니다.

```typescript
const colorCheckboxListView = new ColorCheckboxListView([
  { code: 'red' },
  { code: 'green', checked: true },
  { code: 'blue' },
  { code: 'yellow' },
]);

document.body.appendChild(colorCheckboxListView.render());

colorCheckboxListView.addEventListener('checkboxlist:change', function () {
  console.log(this.checkedData().map(({ code }) => code));
  // ['green', 'blue']
});
```

### 1급 객체 활용

`ColorView`를 포함하여 코드를 다시 보겠습니다.

```typescript
export type Color = {
  code: string;
  checked?: boolean;
};

export class ColorView extends View<Color> {
  template({ code }: Color) {
    return html`
      <div style="background-color: ${code}"></div>
    `;
  }
}

export class ColorCheckboxView extends CheckboxView<Color> {
  SubView = ColorView;
}

export class ColorCheckboxListView extends CheckboxListView<Color> {
  CheckboxView = ColorCheckboxView;
}
```

만일 `ColorCheckboxView`를 사용하지 않는다면 아래와 같이 코드를 작성할 수 있습니다.

```typescript
export class ColorView extends View<Color> {
  template({ code }: Color) {
    return html`
        <div style="background-color: ${code}"></div>
      `;
  }
}

export class ColorCheckboxListView extends CheckboxListView<Color> {
  CheckboxView = class ColorCheckboxView extends CheckboxView<Color> {
    SubView = ColorView;
  };
}
```

마찬가지로 `ColorView`도 사용하지 않는다면 아래와 같이 구현할 수 있습니다.

```typescript
export class ColorCheckboxListView extends CheckboxListView<Color> {
  CheckboxView = class ColorCheckboxView extends CheckboxView<Color> {
    SubView = class ColorView extends View<Color> {
      template({ code }: Color) {
        return html`
          <div style="background-color: ${code}"></div>
        `;
      }
    };
  };
}
```

### html을 활용하여 좀 더 쉽게 추상화하기

위에서 `CheckboxView`를 구현한 방식은 타입 정의를 잘해주어야하기 때문에 추상화가 약간 어렵습니다. rune의 템플릿 함수를 활용하면 아래처럼 좀 더 쉽게 추상화할 수 있습니다. 

```typescript
export class CheckboxView<T extends CheckboxData> extends View<T> {
  tagName: string = 'li';

  template({ checked }: T) {
    return html`
      <${this.tagName} class="${checked ? 'checked' : ''}">
        ${this.createSubView()}
      </${this.tagName}>
    `;
  }

  createSubView() {
    return html``;
  }
}

export class ColorCheckboxView extends CheckboxView<Color> {
  createSubView() {
    return html`${new ColorView(this.data)}`;
  }
}
```

## Enable

rune은 하나의 `View`에 여러개의 기능을 부여하는 Enable 패턴을 제공합니다. `Enable`을 이용하면 동작이나 기능을 모듈화하고 `View`를 확장하기 용이한 개념이자 클래스입니다. `Enable`은 템플릿이 없는 `View`와 같다고 생각하면 쉬우며 `View`를 받아 기능을 확장하는 패턴을 보여줍니다.

### View와 데이터를 공유하는 Enable

`Enable`은 `View`와 데이터를 공유할 수 있도록 설계되었습니다. 타입스크립트에서는 `Enable<T>`의 type argument로 `View<T>`의 type argument인 `view.data`와 동일한 타입을 전달하면 됩니다. 이전에 만들었던 `CheckboxView`를 `Enable`을 활용할 경우 아래와 같은 패턴으로 구현할 수 있습니다. `Checkable<T extends CheckableData>`는 `Checkable`를 생성할 때 전달할 `View`의 `data`의 타입을 제약합니다.

```typescript
import { View, html, Enable } from 'rune-ts';

type CheckableData = {
  checked?: boolean;
};

class Checkable<T extends CheckableData> extends Enable<T> {
  @on('click')
  toggle() {
    this.view.data.checked = !this.view.data.checked;
    this.view.element().classList.toggle('checked');
    this.view.element().dispatchEvent(
      new CustomEvent('checkable:change', { bubbles: true })
    );
  }
}

type Color = {
  code: string;
  checked?: boolean;
};

class CheckableColorView extends View<Color> {
  checkable = new Checkable(this).init();
  
  template(color: Color) {
    return html`
      <div class="${color.checked ? 'checked' : ''}" style="background-color: ${color.code}">
      </div>
    `;
  }
}

const checkableColorView = new CheckableColorView({ code: 'red' });
checkableColorView.render().dispatchEvent(new MouseEvent('click'));
console.log(checkableColorView.data.checked);
// true
```

`Enable.prototype.onMount`는 인자로 받은 `View`의 `element`가 브라우저에 추가(append) 되었을 때 실행됩니다. 또한 `Enable`도 `View`처럼 `addEventListener`를 가지고 있습니다.

```typescript
toggle() {
  this.data.checked = !this.data.checked;
  this.element().classList.toggle('checked');
  this.element().dispatchEvent(
    new CustomEvent('checkable:change', { bubbles: true })
  );
}
```

`Enable`에서 `this.view.data === this.data` 이고 `this.view.element() === this.element()` 이기 때문에 toggle 영역을 위 코드처럼 변경할 수 있습니다. 이는 `View`를 작성할 때 만들었던 코드를 `Enable`로 옮겨 재사용가능한 코드로 만들고자 할 때 용이하게 합니다.


### 데이터 공유가 없는 View 확장

`Deletable`을 사용하여 클릭했을 때 삭제되는 `BallView`를 쉽게 만들 수 있습니다.

```typescript
class Deletable extends Enable<unknown> {
  onMount() {
    this.delegate('mousedown', '.remove-target', this.remove);
  }

  remove() {
    this.element().remove();
  }
}

type Ball = {
  color: string
}

class BallView extends View<Ball> {
  deletable = new Deletable(this).init();

  template() {
    return html`
      <div style="
         border: 1px solid black; 
         padding: 10px;
         width: 20px; 
         height: 20px;
         border-radius: 20px;">
        <div class="remove-target" style="
           background-color: ${this.data.color}; 
           width: 100%; 
           height: 100%; 
           border-radius: 10px;"></div>
      </div>
    `;
  }
}

[{ color: 'red' }, { color: 'green' }, { color: 'blue' }]
    .map((ball) => new BallView(ball))
    .forEach((ballView) => {
      document.body.appendChild(ballView.render());
    });
```

### ViewExtraInterface

위 코드에서는 `Deletable`의 삭제를 트리거하는 엘리먼트의 클래스명을 `remove-target`라는 문자열로 약속을 했습니다. `interface`를 활용하면 객체간 통신의 규약을 더 확장성이 있으면서도 안전하게 추상화할 수 있습니다.

```typescript
interface DeletableViewExtraInterface {
  readonly targetClassName: string;
}

export class Deletable extends Enable<unknown, DeletableViewExtraInterface> {
  onMount() {
    this.delegate('mousedown', `.${this.view.targetClassName}`, this.remove);
  }

  remove() {
    this.element().remove();
  }
}

export class BallView extends View<Ball> {
  deletable = new Deletable(this).init();
  
  readonly targetClassName = 'target';

  template() {
    return html`
      <div style="
         border: 1px solid black; 
         padding: 10px; 
         width: 20px; 
         height: 20px; 
         border-radius: 20px;">
        <div class="${this.targetClassName}" style="
           background-color: ${this.data.color}; 
           width: 100%; 
           height: 100%; 
           border-radius: 10px;"></div>
      </div>
    `;
  }
}
```

이제 `BallView`에서 `targetClassName`를 구현하지 않는다면 `Argument of type this is not assignable to parameter of type View<unknown> & DeletableViewExtraInterface`와 같은 에러메시지가 출력되어 개발자가 반드시 구현하도록 가이드를 줄 수 있습니다.

다음은 객체간 통신의 예시로 `Deletable`이 `View`에게 `canRemove()`를 물어보고 삭제하도록 인터페이스와 구현을 추가했습니다.

```typescript
interface DeletableViewExtraInterface {
  readonly targetClassName: string;
  canRemove(): boolean;
}

export class Deletable extends Enable<unknown, DeletableViewExtraInterface> {
  onMount() {
    this.delegate('mousedown', `.${this.view.targetClassName}`, this.remove);
  }

  remove() {
    if (this.view.canRemove()) {
      this.element().remove();
    }
  }
}

export type Ball = {
  color: string;
  count: number;
};

export class BallView extends View<Ball> {
  deletable = new Deletable(this).init();
  
  readonly targetClassName = 'target';
  
  canRemove() {
    return confirm('삭제하시겠습니까?');
  }

  template() {
    return html`
      ...
    `;
  }
}
```


### 두 개 이상의 Enable

`Enable`을 이용하면 하나의 `View`에 두 개 이상의 기능을 부여할 수 있습니다.

```typescript
class Movable extends Enable<unknown> {
  onMount() {
    this.element().animate(
      [
        { transform: 'translateX(0px)' },
        { transform: 'translateX(300px)' },
        { transform: 'translateX(0px)' },
      ],
      {
        duration: 5000,
        iterations: Infinity,
      },
    );
  }
}

type Ball = {
  color: string
}

export class BallView extends View<Ball> {
  movable = new Movable(this).init();
  deletable = new Deletable(this).init();
  
  readonly targetClassName = 'target';
  
  canRemove() {
    return confirm('삭제하시겠습니까?');
  }

  template() {
    return html`
      ...
    `;
  }
}
```

이제 `BallView`는 화면에 그려진 후 횡으로 반복 이동하며 클릭하면 삭제됩니다. `Ball`에 `count`를 추가하고 `canRemove` 구현을 살짝 고쳐보겠습니다.

```typescript
export type Ball = {
  color: string;
  count: number;
};

export class BallView extends View<Ball> {
  movable = new Movable(this).init();
  deletable = new Deletable(this).init();
  
  readonly targetClassName = 'target';

  canRemove() {
    return --this.data.count === 0;
  }

  template() {
    return html`
      ...
    `;
  }
}

const balls = [
  { color: 'red', count: 3 },
  { color: 'green', count: 2 },
  { color: 'blue', count: 1 },
];
balls
  .map((ball) => new BallView(ball))
  .forEach((ballView) => {
    document.body.appendChild(ballView.render());
  });
```

이제 횡으로 반복하는 공을 여러번 클릭해야 터지는 간단한 게임이 완성되었습니다.

위 코드들은 간결하며 재사용성이 높습니다. 다만 너무 많은 객체간의 통신은 부작용을 조심해야하며 개발자는 객체들이 서로 간섭하지 않도록 유의해야합니다. 본 문서에서는 rune의 기능과 코딩 패턴을 소개하기 위해 의도적으로 작은 컴포넌트를 만들었습니다. 문제를 작게 만들어 해결하는 것은 좋지만 하나의 컴포넌트가 충분한 역할을 가지도록 설계할 필요가 있습니다.